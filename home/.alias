#! /usr/bin/bash

unalias -a
function exists() { command -v $1 >/dev/null 2>&1 }
alias up.dotfiles='mkdir $HOME/code; rm -rf $HOME/code/dotfiles && git clone  https://github.com/arafatm/dotfiles.git $HOME/code/dotfiles && unalias -a && source $HOME/.zshrc'

# From https://fam.tuwien.ac.at/~schamane/_/mycolorize
bgred=$(tput setab 1)
bgyel=$(tput setab 3)
bred=$(tput setaf 1)$(tput bold)
red=$(tput setaf 1)
red=$(tput setaf 1)
gre=$(tput setaf 2)
yel=$(tput setaf 3)
blu=$(tput setaf 4)
mag=$(tput setaf 5)
cya=$(tput setaf 6)
nor=$(tput sgr0) # reset colors
# tput setab for background
# tput bold

if exists ssh; then
  alias sshfurahadev='ssh arafatm@dev.furahasoftware.com'
  alias sshkodi='ssh -oServerAliveInterval=60 kodi@192.168.0.100'
  alias sshproxy='ssh -oServerAliveInterval=60 -D 1234 arafatm@leanfolio.com'
fi

if grep -qi microsoft-standard-WSL2 /proc/version; then 
  alias expl='explorer.exe .' # windows WS
  alias ssh-add='ssh-add.exe' 
  alias ssh='ssh.exe'
  export GIT_SSH_COMMAND='ssh.exe'
fi

if [[ $OSTYPE =~ 'darwin' ]] then 
  alias brew='brew'
  alias cask='brew cask'
  alias ls='ls --color=tty'
  alias maccamera='sudo killall VDCAssistant' # reset osx camera 
  alias pg_start='launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist'
  alias pg_stop='launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist'
  alias sed='gsed'
else 
  alias ls='ls --color=auto'
fi

if exists zsh; then
  alias z="unalias -a; source $HOME/.zshrc"
  alias zsrc='unalias -a; pushd $HOME/dotfiles; git pull; source ~/.zshrc; popd'
fi

if exists apt; then
  alias aapt='alias | grep apt'
  alias aptd='sudo apt dist-upgrade'
  alias aptf='apt show'
  alias apti='sudo apt install'
  alias aptm='sudo apt-cache madison'
  alias apts='apt search'
  alias aptsh='apt show'
  alias aptu='sudo apt update'
fi

if exists nvim; then 
  alias :e='nvim'
  alias v='nvim -R'
  alias vi='nvim'
  alias vim='nvim'
else
  alias v='vi -R'
fi

if exists postgres; then alias pgsql='sudo -u postgres psql'; fi

if exists git; then
  alias randmd='find . -type f |grep -v .git | shuf -n 1'

  alias al.git='alias | grep git'
  alias al.ggit='alias | grep ggit'

  alias cdr='cd `git rev-parse --show-toplevel`'
  alias vr='vim  $(git rev-parse --show-toplevel)/readme.md'

  alias git.branch='git branch --color'
  alias git.branchclean='git branch --merged main | grep -v "main" | xargs -n 1 git branch -d'
  alias git.checkout='git checkout'
  alias git.commitall='git commit -a'
  alias git.conf='git config -l'
  alias git.confl='git config -l --local'
  alias git.d='git diff HEAD .'
  alias git.dir="find . -type d -name .git -print -execdir git status --porcelain \;"
  alias git.fetchall='find . -type d -depth 1 -exec git --git-dir={}/.git --work-tree=$PWD/{} pull origin main \;'
  alias git.heroku='git pull; git push; git push heroku main'
  alias git.hubclone='github_clone'
  alias git.l='git log --graph --decorate --pretty=oneline --abbrev-commit --all'
  alias git.la='git log --decorate'
  alias git.ls='git ls-files'
  alias git.merge='git merge'
  alias git.mergemain='git merge main'
  alias git.mkd='git log --reverse | grep -v "^commit" | grep -v "^Author" | grep -v "^Date"'
  alias git.st='git status'
  alias git.sync='( git pull && git push ) &'
  alias git.tree='git log --oneline --decorate --all --graph'

  alias ggit.addcommit='ggit_add_and_commit_all'
  alias ggit.branchtrack='ggit_branch_and_track'
  alias ggit.ca='ggit_commit_all'
  alias ggit.checkoutremote='ggit_checkout_remote'
  alias ggit.cleanhistory='ggit_clean_history'
  alias ggit.commitlastcommand='ggit_commit_last_command'
  alias ggit.commitwithdefaultmessage='ggit_commit'
  alias ggit.note='ggit_note'

  alias rgit.c='ggit_readme_append_last_command'
  alias rgit.d='ggit_readme_append_diff'
  alias rgit.l='ggit_readme_append_link'
  alias rgit.n='ggit_readme_append_note'
fi

if exists ruby; then
  alias al.bund='alias |grep bundle'
  alias al.rake='alias |grep rake'
  alias al.rail='alias |grep rails'
  alias bund='bundle'                    # Vendor everything still applies
  alias bund.exec='bundle exec'
  alias bund.init='bundle_init'
  alias bund.update='bundle update'
  alias rake='bundle exec rake'
  alias rake.dbreload='bundle exec rake db:drop && rk db:create && rk db:schema:load && rk db:fixtures:load'
  alias rake.fixtures='bundle exec rake db:fixtures:load'
  alias rake.migrate='bundle exec rake db:migrate' 
  alias rake.seed='bundle exec rake db:seed'
  alias rake.test='bundle exec rake test'
  alias rail='bundle exec rails'
  alias rail.lc='bundle exec rails console'
  alias rail.lcontroller='bundle exec rails generate controller'
  alias rail.lg='bundle exec rails generate'
  alias rail.lmodel='bundle exec rails generate model'
  alias rail.ls='bundle exec rails s -b 0.0.0.0'
  alias rail.lscaffold='bundle exec rails generate --skip scaffold'
  alias rail.lt='bundle exec rails test'
fi

#if exists python3; 
# then alias py='python3'
# alias pip='pip3'
# alias python='python3'
#fi

if exists terraform; then alias tf='terraform'; fi

if exists docker; then
  alias al.dok='alias | grep dok'
  alias dok='docker'
  alias dok.update.images='docker images | grep -v REPOSITORY | awk '{print $1}' | xargs -L1 docker pull'
  alias dok.restart='docker compose restart'
  alias dok.compose="docker-compose"
  alias dok.shell='docker_shell'
fi

if exists minikube; then
  alias al.mk='alias | grep minikube'
  alias mk='minikube'
  alias mk.s='minikube start'
fi

if exists tmux; then
  alias tma='tmux attach -t'
  alias tmc='tmux attach -t `basename $PWD` || tmux new -s `basename $PWD`'
  alias tml='tmux list-sessions'
  alias tmm='tmux new-session -A -s main'
  alias tmn='tmux new-window -c $PWD'
  alias tms='tmux split-window -c $PWD'
  alias tmx='tmux a -t `basename $PWD`'
fi

if exists batcat; then alias c='batcat'; else alias c='cat'; fi
alias alg='alias | grep'
alias bkps='$HOME/bin/bkps.git.cron'
alias cdc="cd $HOME/code"
alias cdw='cd $HOME/code/work'
alias cp='cp -i'
alias df='df -h -x aufs -x tmpfs -x udev'
alias du='du -h'
alias du.size='directory_by_size'
alias du.size.sorted='directory_by_size_sorted'
alias grep='grep --color'       # show differences in colour
alias i3='cat $HOME/ca/notes/i3.md'
alias i3g='cat $HOME/ca/notes/i3.md | grep -i '
alias jc="journalctl -n 100 -f"
alias jcu="jc -u"
alias l='ls -CF'                              #
alias la='ls -A'                              # all but . and ..
alias less='less -r'                          # raw control characters
alias ll='ls -l'                              # long list
alias lla='ls -alh'                              # long list
alias llt='ls -lt'
alias lnk='greplinks'
alias lt='ls -t'
alias mdcat="pandoc -f markdown -t plain"     # markdown
alias more='less'
alias mv='mv -i'
alias q='myquote'
alias rebash='exec $SHELL'
alias rm='rm -i'
alias standby='sudo /etc/acpi/sleep.sh'
alias sudid='sudo -E !!'
alias sudo='sudo -E'
alias swp='setxkbmap -option caps:swapescape'
alias sys='sudo systemctl'
alias torr='aria2c -u40K --seed-time=0'
alias whatismyip='dig +short myip.opendns.com @resolver1.opendns.com'
alias whence='type -a'                        # where, of a sort

function bundle_init() { bundle install --path vendor && bundle package && if [[ ! $(grep "vendor/ruby" .gitignore) ]]; then echo 'vendor/ruby' >> .gitignore; fi ; }

function cleankernels() { echo $(dpkg --list | grep linux-image | awk '{ print $2 }' | sort -V | sed -n '/'`uname -r`'/q;p') $(dpkg --list | grep linux-headers | awk '{ print $2 }' | sort -V | sed -n '/'"$(uname -r | sed "s/\([0-9.-]*\)-\([^0-9]\+\)/\1/")"'/q;p') | xargs sudo apt-get -y purge ; }

function directory_by_size() { local arg1=${1:-.} && du -ahd 1 $arg1 ; }

function directory_by_size_sorted() { directory_by_size $1 | sort -h ; }

function docker_shell() { docker exec -it $1 bash ; }

function em() { emacs $1 & ; }

function ggit_note() {
  git commit --allow-empty --cleanup=whitespace -m "$*" && git push
}
function ggit_pages() {
  if [[ "$(basename $(pwd))" != "ghp" ]]; then
    git pull
    rm -rf ghp .gitmodules .git/modules .github
    wget https://github.com/arafatm/ghp/tarball/main -O - | tar -xz --one-top-level=ghp --strip-components=1 
    mkdir -p .github/workflows && cp ghp/.github/workflows/ghp.yml .github/workflows/ghp.yml
    ghpArr=( "Gemfile" "_config.yml" "_includes" "_layouts" "favicon.ico" )
    for item in ${ghpArr[@]}; do
      rm -rf $item
      cp -r ghp/$item .
      echo "deleted and copied $item"
    done
    if [[ -n $(git status --short) ]]; then
      git add .
      git commit -am "Setting up Pages"
      git push
    fi
    echo "--- Updated hash: $(git rev-parse HEAD)"
    curl -L -X POST -H "Accept: application/vnd.github+json" \
      -H "Authorization: Bearer $GH_TOKEN" -H "X-GitHub-Api-Version: 2022-11-28" \
      https://api.github.com/repos/arafatm/$(basename $(pwd))/pages -d '{"source":{"branch":"main"}}'
  fi
}

function ggit_arafatm() {
  git init; git add . ; git commit -m "init"
  gh repo create $(basename $(pwd)) --source=. --remote=upstream --push --public
  sleep 5
  git branch -M main; git push -u origin main 
}

function ggit_add_and_commit_all() { git add . && git commit . -m "$*" && git push & ; }

function ggit_branch_and_track() { git branch $1 && git push origin $1:$1 && git co $1 && git branch --set-upstream-to=origin/$1 $1 ; }

function ggit_checkout_remote() { git checkout --track -b $1 origin/$1 ; }

function ggit_clean_history() { 
  git checkout --orphan latest_branch
  git add -A
  git commit -am "init"
  git branch -D main
  git branch -m main
  git push -f origin main
}

function ggit_commit() {
  array=( $@ ) && len=${#array[@]} && _file=${array[0]} && _args=${array[@]:1:$len-1}
  git add $_file && git commit $_file -m "$_args"
  #echo "adding $_file" && echo "commit msg $_args"
}
function ggit_commit_all() { git add . && git commit -a -m "$*" ; }

function ggit_commit_last_command() { HIS=$(history|tail -n 2|head -n 1|sed 's/ *[0-9]* *//') && git add . && git commit . -m "\$ $HIS" ; }

function ggit_readme_append_commit() {
  url=$(git config --get remote.origin.url) && url=${url:15:-4} && url="https://github.com/$url"
  commit=$(git log --oneline -n 1) && sha=${commit:0:7} && msg=${commit:8} && url="$url/commit/$sha"
  msg="$* [$msg]($url)\n" && echo "commit: $msg"
  gitroot=$(git rev-parse --show-toplevel) && sed -z -i "s^xxx^$msg\nxxx^" $gitroot/readme.md && git push &
}

function ggit_parse_gh_url() {
  local repo=$1
  repo=${repo%%.git}
  repo=${repo##*:}
  repo="https://github.com/$repo"
  echo $repo
}

function ggit_readme_append_link() {
  msg="$*"; if [[ -z $msg ]]; then echo "No commit message" && return 1; else echo "Committing with $msg"; fi
  git add . && gitdif=$(git diff HEAD .) && git commit . -m  $msg && gitroot=$(git rev-parse --show-toplevel)
  commit=$(git log --oneline -n 1) ; sha=${commit:0:7} ; msg=${commit:8} ; bt='```'
  local repo_url="$(git config --get remote.origin.url)"
  repo_url=$(ggit_parse_gh_url "$repo_url")
  echo "repo: $repo_url"
  local msg="🚢 [${sha}](${repo_url}/commit/${sha}) \n${msg}"
  echo "mgs: $msg"
  sed -z -i "s^xxx^${msg}\n\nxxx^" $gitroot/readme.md 
  git push &
}

function ggit_readme_append_diff() {
  local msg="$*"; if [[ -z $msg ]]; then echo "No commit message" && return 1; else echo "Committing with $msg"; fi
  git add . && gitdif=$(git diff HEAD .) && git commit . -m  $msg && gitroot=$(git rev-parse --show-toplevel)
  commit=$(git log --oneline -n 1) ; sha=${commit:0:7} ; msg=${commit:8} ; bt='```'
  local repo_url="$(git config --get remote.origin.url)"
  repo_url=$(ggit_parse_gh_url "$repo_url")
  echo "repo: $repo_url"
  local msg="🚢 [${sha}](${repo_url}/commit/${sha}) \n${msg}"
  echo "mgs: $msg"
  sed -z -i "s^xxx^${msg}\nxxx^" $gitroot/readme.md 
  sed -z -i "s^xxx^\`\`\`diff\nxxx^" $gitroot/readme.md 
  while IFS= read -r line; do 
    skip=false
    if [[ "$line" =~ "^index [0-9a-z]{7}\.\..*" ]]; then skip=true; fi
    if [[ "$line" =~ "^--- [ab/].*" ]]; then skip=true; fi
    if [[ "$line" =~ "^\+\+\+ [ab/].*" ]]; then skip=true; fi
    if [[ "$line" =~ "^diff --git a.*" ]]; then 
      sed -z -i "s^xxx^\nxxx^" $gitroot/readme.md
      line=$(echo "$line" | sed 's$\(diff --git a/.*\) b/.*$\1$'); 
    fi
    if [[ "$skip" = false ]]; then sed -z -i "s^xxx^$line\nxxx^" $gitroot/readme.md; fi
  done <<< "$gitdif"
  sed -z -i "s^xxx^\`\`\`\n\nxxx^" $gitroot/readme.md 
  git push &
}

function ggit_readme_append_last_command() {
  lastcommand=$(history | tail -n 1 | sed 's/ *[0-9]* *//')
  echo "---\nlastcommand = $lastcommand\n---"
  flag_diff=1
  if [[ $(git status -s .) ]]; then 
    git add . && git commit . -m  "\`${lastcommand}\`" 
  else 
    flag_diff=0 
    git commit --allow-empty --cleanup=whitespace -m "\`${lastcommand}\`" 
  fi
  commit=$(git log --oneline -n 1) && sha=${commit:0:7} 
  local repo_url="$(git config --get remote.origin.url)"
  repo_url=$(ggit_parse_gh_url "$repo_url")
  echo "repo: $repo_url"
  msg="🚢 [${sha}](${repo_url}/commit/${sha}) \n\`\`\`bash\n${lastcommand}\n\`\`\`"
  #if [[ $flag_diff == 1 ]]; then msg="${msg} # [diff](${repo_url})/commit/${sha}"; fi
  gitroot=$(git rev-parse --show-toplevel) && sed -z -i "s^xxx^${msg}\n\nxxx^" $gitroot/readme.md && git push &
}

function ggit_readme_append_note() { 
  git commit --allow-empty --cleanup=whitespace -m "$*" 
  url="https://github.com/$(git config --get remote.origin.url | cut -d':' -f 2)" 
  commit=$(git log --oneline -n 1) && sha=${commit:0:7} && msg=${commit:8} && url="$url/commit/$sha"
  msg=":bulb: __${msg}__" 
  gitroot=$(git rev-parse --show-toplevel) && sed -z -i "s^xxx^$msg\n\nxxx^" $gitroot/readme.md && git push &
}

function gio() { mv $* $HOME/code/$USER/$USER.github.io/_new/$* ; }

function github_clone() { git clone git@github.com:$1 ; }

function greplinks() {
  lnks="grep '\[\S.\+](' *.md"
  lnks="$links | sed -e 's/^.*\(\[\S.\+](.*)\)/\1/'"
  lnks="$links | sed -e 's/\(\[\S.\+]\)/$cya\1$nor/g'" 
  lnks="$links | sort"
  eval $lnks && echo -e $lnks
}

function herbr() {
  if [ -z "$1" ]; then echo "Please provide the name of the heroku app";
  else
    BRANCH=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
    echo "Deploying branch $BRANCH to $1" && read -p "Are you sure? " -n 1 -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git pull && git merge origin/main && git push && git push heroku $BRANCH:main
      heroku pg:reset DATABASE_URL --confirm $1 && heroku run rake db:schema:load && heroku run rake db:seed
    fi
  fi
}

# vim: set ft=zsh:
# vim: set textwidth=0:
# vim: set wrapmargin=0:
# vim: set nowrap:
# vim: set foldlevel=9:
